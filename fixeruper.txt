




para hacer peticiones sin https:
  process.env[ "NODE_TLS_REJECT_UNAUTHORIZED" ] = "0"

para hacer componentes de jsx que sean asyncr√≥nicos sin activar el Promise<Element> is not a JSX Element error:
  {/* @ts-expect-error Async Server Component */ }

  https://insiders.vscode.dev/github/CachorroC/app/blob/notebook/src/app/Procesos/page.tsx



promessing but not quite:

 const act = getActuacionFecha(
              { idProceso: row.idProceso }
            ).then(
              (
                fullfiled
              ) => {
                const fl = fullfiled;
                return fl;
              },
              (async() => await fetchRetry(
                row.idProceso
              ))
            );







  procesos.forEach(
    (
      proceso, index, procArr
    ) => {

      const iOfA = `${index + 1}-${procArr.length}`;
      setTimeout(
        async () => {
          const idProceso = proceso.idProceso;
          const helper = await fetchActuaciones(
            idProceso,
            iOfA
          );
          helpers.push(
            helper
          );
          if ( helper.acts[0] ) {
            const fechaUltimaAct = helper.acts[ 0 ].fechaActuacion;
            rows.push(
              <Suspense key={ proceso.idProceso } fallback={<CardSkeleton/>}>
                <Card key={ proceso.idProceso } index={  index} path={ '/Procesos' } llaveProceso={ proceso.llaveProceso } array={ procArr} title={ proceso.sujetosProcesales } actuacion={ false }>
                  <Suspense fallback={<sub className={card.date}>loading</sub>}>
                    <sub className={card.date}>{fixFechas(
                      fechaUltimaAct
                    )}</sub>
                  </Suspense>
                </Card>
              </Suspense>
            );
          }
        },
        index * 2000
      );
    }
  );








  const carpetasMap = new Map ();

  const lastActuacionesMapSorted = new Map ();

  const lastActuacionesArraySorted: intFecha[] = [];

  const lastActuacionesSorted = [
    ... carpetas
  ].sort (
    (
      a, b
    ) => {
      if ( !a.fecha || a.fecha === undefined || a.fecha === null ) {
        return 1;
      }
      if ( !b.fecha || b.fecha === undefined ||  b.fecha === null ) {
        return -1;
      }
      console.log (
        typeof a.fecha
      );
      console.log (
        typeof b.fecha
      );
      let x = typeof a.fecha === 'string'
        ? a.fecha.toLowerCase ()
        : a.fecha.toISOString ();
      let y =  typeof b.fecha === 'string'
        ? b.fecha.toLowerCase ()
        : b.fecha.toISOString ();
      if ( x < y ) {
        return 1;
      }
      if ( x > y ) {
        return -1;
      }
      return 0;
    }
  );
  lastActuacionesSorted.forEach (
    (
      lastAct
    ) => {
      lastActuacionesArraySorted.push (
        lastAct
      );
      return lastActuacionesMapSorted.set (
        lastAct._id,
        lastAct
      );
    }
  );
  carpetas.forEach (
    (
      carpeta
    ) => {
      return carpetasMap.set (
        carpeta._id,
        carpeta
      );
    }
  );